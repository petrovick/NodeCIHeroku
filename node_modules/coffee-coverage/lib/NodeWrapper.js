// Generated by CoffeeScript 1.7.1
(function() {
  var NodeWrapper, assert, coffeeScript, compile, forNodeAndChildren, _;

  assert = require('assert');

  coffeeScript = require('coffee-script');

  _ = require('lodash');

  module.exports = NodeWrapper = (function() {
    function NodeWrapper(node, parent, childName, childIndex, depth) {
      var _ref, _ref1;
      this.node = node;
      this.parent = parent;
      this.childName = childName;
      this.childIndex = childIndex;
      this.depth = depth != null ? depth : 0;
      assert(this.node);
      this.locationData = this.node.locationData;
      this.type = ((_ref = this.node.constructor) != null ? _ref.name : void 0) || null;
      this.isStatement = (this.parent != null) && this.type !== 'Comment' && this.parent.type === 'Block' && this.childName === 'expressions';
      if (this.isStatement && this.type === 'Value' && ((_ref1 = this.parent.parent) != null ? _ref1.type : void 0) === 'Class') {
        this.isStatement = false;
      }
    }

    NodeWrapper.prototype.forEachChild = function(fn) {
      if (this.node.children != null) {
        return this.node.children.forEach((function(_this) {
          return function(childName) {
            return _this.forEachChildOfType(childName, fn);
          };
        })(this));
      }
    };

    NodeWrapper.prototype.forEachChildOfType = function(childName, fn) {
      var child, childNodes, children, index, wrappedChild, _results;
      children = this.node[childName];
      if (children != null) {
        childNodes = _.flatten([children], true);
        index = 0;
        _results = [];
        while (index < childNodes.length) {
          child = childNodes[index];
          if (child.constructor.name != null) {
            wrappedChild = new NodeWrapper(child, this, childName, index, this.depth + 1);
            fn(wrappedChild);
          }
          _results.push(index++);
        }
        return _results;
      }
    };

    NodeWrapper.prototype.markAll = function(varName, value) {
      var markCoffeeNode;
      if (value == null) {
        value = true;
      }
      markCoffeeNode = function(coffeeNode) {
        if (coffeeNode.coffeeCoverage == null) {
          coffeeNode.coffeeCoverage = {};
        }
        coffeeNode.coffeeCoverage[varName] = value;
        return coffeeNode.eachChild(markCoffeeNode);
      };
      return markCoffeeNode(this.node);
    };

    NodeWrapper.prototype.mark = function(varName, value) {
      var _base;
      if (value == null) {
        value = true;
      }
      if ((_base = this.node).coffeeCoverage == null) {
        _base.coffeeCoverage = {};
      }
      return this.node.coffeeCoverage[varName] = value;
    };

    NodeWrapper.prototype.isMarked = function(varName, value) {
      var _ref;
      if (value == null) {
        value = true;
      }
      return ((_ref = this.node.coffeeCoverage) != null ? _ref[varName] : void 0) === value;
    };

    NodeWrapper.prototype.child = function(name, index) {
      var child;
      if (index == null) {
        index = null;
      }
      child = this.node[name];
      if (!child) {
        return null;
      }
      if (index == null) {
        assert(!_.isArray(child));
        return new NodeWrapper(child, this, name, 0, this.depth + 1);
      } else {
        assert(_.isArray(child));
        if (!child[index]) {
          return null;
        }
        return new NodeWrapper(child[index], this, name, index, this.depth + 1);
      }
    };

    NodeWrapper.prototype._fixChildIndex = function() {
      var childIndex;
      if (!_.isArray(this.parent.node[this.childName])) {
        return this.childIndex = 0;
      } else {
        if (this.parent.node[this.childName][this.childIndex] !== this.node) {
          childIndex = _.indexOf(this.parent.node[this.childName], this.node);
          if (childIndex === -1) {
            throw new Error("Can't find node in parent");
          }
          return this.childIndex = childIndex;
        }
      }
    };

    NodeWrapper.prototype.next = function() {
      var nextNode, _ref;
      if ((_ref = this.parent.type) !== 'Block' && _ref !== 'Obj') {
        return null;
      }
      this._fixChildIndex();
      nextNode = this.parent.node[this.childName][this.childIndex + 1];
      if (nextNode == null) {
        return null;
      } else {
        return new NodeWrapper(nextNode, this.parent, this.childName, this.childIndex + 1, this.depth);
      }
    };

    NodeWrapper.prototype._insertBeforeIndex = function(childName, index, csSource) {
      var compiled;
      assert(_.isArray(this.node[childName]), "" + (this.toString()) + " -> " + childName);
      compiled = compile(csSource, this.node);
      return this.node[childName].splice(index, 0, compiled);
    };

    NodeWrapper.prototype.insertBefore = function(csSource) {
      this._fixChildIndex();
      return this.parent._insertBeforeIndex(this.childName, this.childIndex, csSource);
    };

    NodeWrapper.prototype.insertAfter = function(csSource) {
      this._fixChildIndex();
      return this.parent._insertBeforeIndex(this.childName, this.childIndex + 1, csSource);
    };

    NodeWrapper.prototype.insertAtStart = function(childName, csSource) {
      var child, _ref;
      child = this.node[childName];
      if (this.type === 'Block' && childName === 'expressions') {
        if (!child) {
          return this.node[childName] = [compile(csSource, this.node)];
        } else {
          return this.node[childName].unshift(compile(csSource, this.node));
        }
      } else if ((child != null ? (_ref = child.constructor) != null ? _ref.name : void 0 : void 0) === 'Block') {
        return child.expressions.unshift(compile(csSource, child));
      } else if (!child) {
        return this.node[childName] = compile(csSource, this.node);
      } else {
        throw new Error("Don't know how to insert statement into " + this.type + "." + childName + ": " + this.type[childName]);
      }
    };

    NodeWrapper.prototype.toString = function() {
      var answer, _ref;
      answer = '';
      if (this.childName) {
        answer += "" + this.childName + "[" + this.childIndex + "]:";
      }
      answer += this.type;
      if (this.node.locationData != null) {
        return answer += " (" + (((_ref = this.node.locationData) != null ? _ref.first_line : void 0) + 1) + ":" + (this.node.locationData.first_column + 1) + ")";
      }
    };

    return NodeWrapper;

  })();

  forNodeAndChildren = function(node, fn) {
    fn(node);
    return node.eachChild(fn);
  };

  compile = function(csSource, node) {
    var compiled, line;
    compiled = coffeeScript.nodes(csSource);
    line = node.locationData.first_line;
    forNodeAndChildren(compiled, function(n) {
      n.locationData = {
        first_line: line - 1,
        first_column: 0,
        last_line: line - 1,
        last_column: 0
      };
      if (n.coffeeCoverage == null) {
        n.coffeeCoverage = {};
      }
      return n.coffeeCoverage.generated = true;
    });
    return compiled;
  };

}).call(this);
